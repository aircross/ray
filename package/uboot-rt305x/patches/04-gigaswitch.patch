--- Uboot-1.1.3/drivers/rt2880_eth.c	2009-12-17 16:48:56.000000000 +0800
+++ Uboot-1.1.3/drivers/rt2880_eth.c	2010-04-23 17:32:05.314340004 +0800
@@ -17,7 +17,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
  * MA 02111-1307 USA
  */
-
+#include <../autoconf.h>
 #include <common.h>
 #include <command.h>
 
@@ -416,6 +416,10 @@
 int   mii_mgr_read(u32 phy_addr, u32 phy_register, u32 *read_data);
 int   mii_mgr_write(u32 phy_addr, u32 phy_register, u32 write_data);
 
+#ifndef EZP
+void athrs16_init(void);
+void athrs16_LAN_WAN_Par(void);
+#endif
 
 static int   rt2880_eth_setup(struct eth_device* dev);
 static int   rt2880_eth_initd;
@@ -724,6 +728,7 @@
 	else
 	{
 		START_RT2880_ETH(dev);
+
 	}
 
 	rt2880_eth_initd = 1;
@@ -792,8 +797,11 @@
 #endif // MAC_TO_100PHY_MODE //
 
 #if defined (RT3052_ASIC_BOARD) || defined (RT3052_FPGA_BOARD)
+	printf("\n RT3052 ASIC Setting switch. \n");
 	*((volatile u32 *)(RALINK_ETH_SW_BASE + 0x14)) = 0x405555; //enable VLAN
 	*((volatile u32 *)(RALINK_ETH_SW_BASE + 0x50)) = 0x2001; //VLAN id
+	*((volatile u32 *)(RALINK_ETH_SW_BASE + 0x54)) = 0x4003; //VLAN id
+	*((volatile u32 *)(RALINK_ETH_SW_BASE + 0x58)) = 0x6005; //VLAN id
 	*((volatile u32 *)(RALINK_ETH_SW_BASE + 0x98)) = 0x7f7f; //remove VLAN tag
 #ifdef RALINK_DEMO_BOARD_PVLAN
 	//WLLLL, wan at P0, demo board
@@ -809,6 +817,17 @@
 	*((volatile u32 *)(RALINK_ETH_SW_BASE + 0x48)) = 0x1002; //PVID
 	*((volatile u32 *)(RALINK_ETH_SW_BASE + 0x70)) = 0xffff506f; //VLAN member
 #endif
+#ifdef RALINK_EZP_BOARD_PVLAN
+	//VVVVV, ALL VLAN, EZP board
+
+	printf("\n EZP Setting VLAN. \n");
+	*((volatile u32 *)(RALINK_ETH_SW_BASE + 0x40)) = 0x2001; //PVID
+	*((volatile u32 *)(RALINK_ETH_SW_BASE + 0x44)) = 0x4003; //PVID
+	*((volatile u32 *)(RALINK_ETH_SW_BASE + 0x48)) = 0x6005; //PVID
+	*((volatile u32 *)(RALINK_ETH_SW_BASE + 0x70)) = 0x48444241; //VLAN member
+	*((volatile u32 *)(RALINK_ETH_SW_BASE + 0x74)) = 0xffffff50; //VLAN member
+	#warning "new ezp board"
+#endif
 #endif // (RT3052_ASIC_BOARD || RT3052_FPGA_BOARD)
 }
 
@@ -913,6 +932,8 @@
 }
 
 #if defined (MAC_TO_GIGAPHY_MODE) || defined (P5_MAC_TO_PHY_MODE) 
+
+
 #define EV_MARVELL_PHY_ID0 0x0141
 #define EV_MARVELL_PHY_ID1 0x0CC2
 static int isMarvellGigaPHY(void)
@@ -935,12 +956,43 @@
         return 0;
 }
 
+#ifdef P5_MAC_TO_PHY_MODE
+#define EV_AR8316_PHY0_ID0 0x004d
+#define EV_AR8316_PHY0_ID1 0xd041
+static int isARGigaPHY(void)
+{
+    	u32 phy_id0,phy_id1;
+	//u32 reg_val;
+
+	//reg_val = le32_to_cpu(*(volatile u_long *)(0xb01100C8));
+	//reg_val &= 0xe0ffffff;//P5 external phy addr = 0x0;
+	//*(volatile u_long *)(0xb01100C8) = cpu_to_le32(reg_val);
+        
+	if( ! mii_mgr_read(0, 2, &phy_id0)){
+                printf("\n Read PhyID 0 is Fail!!\n");
+                //phy_id0 =0;
+        }
+
+        if( ! mii_mgr_read(0, 3, &phy_id1)){
+                printf("\n Read PhyID 1 is Fail!!\n");
+                //phy_id1 = 0;
+        }
+
+        if((phy_id0 == EV_AR8316_PHY0_ID0) && (phy_id1 == EV_AR8316_PHY0_ID1))
+                return 1;
+  
+        printf("\n Cannot find AR8316, write back original reg value! \n");
+        printf("\n PhyID 0 is 0x%08X !!\n",phy_id0);
+        printf("\n PhyID 1 is 0x%08X !!\n",phy_id1);
+        return 0;
+}
+#endif
 
 void enable_auto_negotiate(void)
 {
 	u32 regValue;
 	u32 addr = MAC_TO_GIGAPHY_MODE_ADDR;	// define in config.mk
-
+//get the reg value
 #if defined (RT3052_ASIC_BOARD) || defined (RT3052_FPGA_BOARD) 
 	regValue = le32_to_cpu(*(volatile u_long *)(0xb01100C8));
 #else
@@ -949,9 +1001,9 @@
 
 	regValue &= 0xe0ff7fff;				// clear auto polling related field:
 							// (MD_PHY1ADDR & GP1_FRC_EN).
-	regValue |= 0x20000000;				// force to enable MDC/MDIO auto polling.
+	//regValue |= 0x20000000;				// force to enable MDC/MDIO auto polling.
 	regValue |= (addr << 24);			// setup PHY address for auto polling.
-
+// reg value write back
 #if defined (RT3052_ASIC_BOARD) || defined (RT3052_FPGA_BOARD) 
 	*(volatile u_long *)(0xb01100C8) = cpu_to_le32(regValue);
 #else
@@ -982,77 +1034,77 @@
 #if defined (RT3052_ASIC_BOARD) || defined (RT3052_FPGA_BOARD) //initial cpu + 3052
 void rt305x_esw_init(void)
 {
-	u32	i;
+    int i=0;
 
-	/*                                                                               * FC_RLS_TH=200, FC_SET_TH=160
-	 * DROP_RLS=120, DROP_SET_TH=80
-	 */
-	RT2882_REG(0xb0110008) = 0xC8A07850;       
-	RT2882_REG(0xb01100E4) = 0x00000000;
-	RT2882_REG(0xb0110014) = 0x00405555;
-	RT2882_REG(0xb0110090) = 0x00007f7f;
-	RT2882_REG(0xb0110098) = 0x00007f3f; //disable VLAN
-	RT2882_REG(0xb01100CC) = 0x00d6500c;
-	RT2882_REG(0xb011009C) = 0x0008a301; //hashing algorithm=XOR48, aging interval=300sec
-	RT2882_REG(0xb011008C) = 0x02404040; 
-
-#if defined (RT3052_ASIC_BOARD)
-	RT2882_REG(0xb01100C8) = 0x3f502b28; //Ext PHY Addr=0x1F 
-	RT2882_REG(0xb0110084) = 0x00000000;
-#elif defined (RT3052_FPGA_BOARD)
-	RT2882_REG(0xb01100C8) = 0x20f02b28; //Ext PHY Addr=0x0 
-	RT2882_REG(0xb0110084) = 0xffdf1f00;
-
-	/* In order to use 10M/Full on FPGA board. We configure phy capable to 
-	 * 10M Full/Half duplex, so we can use auto-negotiation on PC side */
-	for(i=0;i<5;i++){
-	    mii_mgr_write(i, 4, 0x0461);   //Capable of 10M Full/Half Duplex, flow control on/off
-	    mii_mgr_write(i, 0, 0xB100);   //reset all digital logic, except phy_reg
-	}
+    /*
+     * FC_RLS_TH=200, FC_SET_TH=160
+     * DROP_RLS=120, DROP_SET_TH=80
+     */
+    *(unsigned long *)(0xb0110008) = 0xC8A07850;
+    *(unsigned long *)(0xb01100E4) = 0x00000000;
+    *(unsigned long *)(0xb0110014) = 0x00405555;
+    *(unsigned long *)(0xb0110050) = 0x00002001;
+    *(unsigned long *)(0xb0110090) = 0x00007f7f;
+    *(unsigned long *)(0xb0110098) = 0x00007f3f; //disable VLAN
+    *(unsigned long *)(0xb01100CC) = 0x00d6500c;
+    *(unsigned long *)(0xb011009C) = 0x0008a301; //hashing algorithm=XOR48, aging interval=300sec
+    *(unsigned long *)(0xb011008C) = 0x02404040;
+#if defined (CONFIG_RT3052_ASIC)
+    *(unsigned long *)(0xb01100C8) = 0x3f502b28; //Change polling Ext PHY Addr=0x1F
+    *(unsigned long *)(0xb0110084) = 0x00000000;
+#elif defined (CONFIG_RT3052_FPGA)
+    *(unsigned long *)(0xb01100C8) = 0x20f02b28; //Change polling Ext PHY Addr=0x0
+    *(unsigned long *)(0xb0110084) = 0xffdf1f00;
+
+    /* In order to use 10M/Full on FPGA board. We configure phy capable to
+     * 10M Full/Half duplex, so we can use auto-negotiation on PC side */
+    for(i=0;i<5;i++){
+        mii_mgr_write(i, 4, 0x0461);   //Capable of 10M Full/Half Duplex, flow control on/off
+        mii_mgr_write(i, 0, 0xB100);   //reset all digital logic, except phy_reg
+    }
 #endif // RT3052_ASIC_BOARD
 
-	/* to lower down PHY 10Mbps mode power */
-	mii_mgr_write(0, 31, 0x8000);	//---> select local register
-	for(i=0;i<5;i++){
-		mii_mgr_write(i, 26, 0x1601); 	//TX10 waveform coefficient
-		mii_mgr_write(i, 29, 0x7058); 	//TX100/TX10 AD/DA current bias
-		mii_mgr_write(i, 30, 0x0018); 	//TX100 slew rate control
-	}
-	/* PHY IOT */
-	mii_mgr_write(0, 31, 0x0);   //select global register
-        mii_mgr_write(0, 1, 0x4a40); //enlarge agcsel threshold 3 and threshold 2
-        mii_mgr_write(0, 2, 0x6254); //enlarge agcsel threshold 5 and threshold 4
-        mii_mgr_write(0, 3, 0xa17f); //enlarge agcsel threshold 6
-        mii_mgr_write(0, 14, 0x65);   //longer TP_IDL tail length
-        mii_mgr_write(0, 17, 0x0fe0); //set TX10 signal amplitude threshold to minimum
-        mii_mgr_write(0, 18, 0x40ba); //set squelch amplitude to higher threshold
-        mii_mgr_write(0, 22, 0x052f); //tune TP_IDL tail and head waveform
-        mii_mgr_write(0, 27, 0x2fc3); //set PLL/Receive bias current are calibrated(RT3350)
-        mii_mgr_write(0, 28, 0xc410); //change PLL/Receive bias current to internal(RT3350)
-        mii_mgr_write(0, 29, 0x598b); //change PLL bias current to internal(RT3052_MP3)
-        mii_mgr_write(0, 31, 0x8000); //select local register
-
+    mii_mgr_write(0, 31, 0x8000);   //---> select local register
+    for(i=0;i<5;i++){
+        mii_mgr_write(i, 26, 0x1601);   //TX10 waveform coefficient
+        mii_mgr_write(i, 29, 0x7058);   //TX100/TX10 AD/DA current bias
+        mii_mgr_write(i, 30, 0x0018);   //TX100 slew rate control
+    }
+    /* PHY IOT */
+    mii_mgr_write(0, 31, 0x0);      //select global register
+    mii_mgr_write(0, 22, 0x052f);   //tune TP_IDL tail and head waveform
+    mii_mgr_write(0, 17, 0x0fe0);   //set TX10 signal amplitude threshold to minimum
+    mii_mgr_write(0, 18, 0x40ba);   //set squelch amplitude to higher threshold
+    mii_mgr_write(0, 14, 0x65);     //longer TP_IDL tail length
+    mii_mgr_write(0, 31, 0x8000);   //select local register
+
+    /* 
+     * set port 5 force to 1000M/Full when connecting to switch or iNIC
+     */
 #if defined (P5_RGMII_TO_MAC_MODE)
-	RT2882_REG(0xb01100C8) &= ~(1<<29); //disable port 5 auto-polling
-	RT2882_REG(0xb01100C8) |= 0x3fff; //force 1000M full duplex
-	RT2882_REG(0xb01100C8) &= ~(0xf<<20); //rxclk_skew, txclk_skew = 0
+#warning "P5_RGMII_TO_MAC_MODE 0xb01100C8 0xb0000060"
+    *(unsigned long *)(0xb0000060) &= ~(1 << 9); //set RGMII to Normal mode
+    *(unsigned long *)(0xb01100C8) &= ~(1<<29); //disable port 5 auto-polling
+    *(unsigned long *)(0xb01100C8) |= 0x3fff; //force 1000M full duplex
+    *(unsigned long *)(0xb01100C8) &= ~(0xf<<20); //rxclk_skew, txclk_skew = 0
 #elif defined (P5_MII_TO_MAC_MODE)
-	RT2882_REG(0xb01100C8) &= ~(1<<29); //disable port 5 auto-polling
-	RT2882_REG(0xb01100C8) |= 0x3ffd; //force 100M full duplex
+    *(unsigned long *)(0xb0000060) &= ~(1 << 9); //set RGMII to Normal mode
+    *(unsigned long *)(0xb01100C8) &= ~(1<<29); //disable port 5 auto-polling
+    *(unsigned long *)(0xb01100C8) |= 0x3ffd; //force 100M full duplex
 #elif defined (P5_MAC_TO_PHY_MODE)
-	enable_auto_negotiate();
-	if (isMarvellGigaPHY()) {
-		unsigned long my_tmp;
-		printf("\n MARVELL Phy\n");
-		mii_mgr_write(MAC_TO_GIGAPHY_MODE_ADDR, 20, 0x0ce0);
-		mii_mgr_write(MAC_TO_GIGAPHY_MODE_ADDR, 0, 0x9140);
-	}
+    *(unsigned long *)(0xb0000060) &= ~(1 << 9); //set RGMII to Normal mode
+    enable_auto_negotiate();
+    if (isMarvellGigaPHY()) {
+        printf("\n MARVELL Phy\n");
+        mii_mgr_write(31,20,0x0ce0);
+        mii_mgr_write(31,0,0x9140);
+    }
 #elif defined (P5_RMII_TO_MAC_MODE)
-	/* Reserved */
-#else /* Port 5 disabled */
-	RT2882_REG(0xb0000060) |= (1 << 9); //set RGMII to GPIO mode (GPIO41-GPIO50)
-	RT2882_REG(0xb0000674) = 0xFFF; //GPIO41-GPIO50 output mode
-	RT2882_REG(0xb0000670) = 0x0; //GPIO41-GPIO50 output low
+    *(unsigned long *)(0xb0000060) &= ~(1 << 9); //set RGMII to Normal mode
+#else // Port 5 Disabled //
+    *(unsigned long *)(0xb0000060) |= (1 << 9); //set RGMII to GPIO mode (GPIO41-GPIO50)
+    *(unsigned long *)(0xb0000674) = 0xFFF; //GPIO41-GPIO50 output mode
+    *(unsigned long *)(0xb0000670) = 0x0; //GPIO41-GPIO50 output low
 #endif // P5_RGMII_TO_MAC_MODE //
 
 }
@@ -1060,327 +1112,337 @@
 
 static int rt2880_eth_setup(struct eth_device* dev)
 {
-	u32	i;
-	u32	regValue;
-	u16	wTmp;
-	uchar	*temp;
-
-	printf("\n Waitting for RX_DMA_BUSY status Start... ");
-	while(1)
-		if(!isDMABusy(dev))
-			break;
-	printf("done\n");
+    u32	i;
+    u32	regValue;
+    u16	wTmp;
+    uchar	*temp;
+
+    printf("\n Waitting for RX_DMA_BUSY status Start... ");
+    while(1)
+        if(!isDMABusy(dev))
+            break;
+    printf("done\n");
 
 
-// GigaPhy
+    // GigaPhy
 #if defined (MAC_TO_GIGAPHY_MODE) 
-	enable_auto_negotiate();
-	if (isMarvellGigaPHY()) {
-  #if defined (RT3883_FPGA_BOARD) 
-		mii_mgr_read(MAC_TO_GIGAPHY_MODE_ADDR, 9, &regValue);
-		regValue &= ~(3<<8); //turn off 1000Base-T Advertisement
-		mii_mgr_write(MAC_TO_GIGAPHY_MODE_ADDR, 9, regValue);
-  #endif
-		printf("\n Reset MARVELL phy\n");
-		mii_mgr_read(MAC_TO_GIGAPHY_MODE_ADDR, 20, &regValue);
-		regValue |= 1<<7; //Add delay to RX_CLK for RXD Outputs
-		mii_mgr_write(MAC_TO_GIGAPHY_MODE_ADDR, 20, regValue);
-
-		mii_mgr_read(MAC_TO_GIGAPHY_MODE_ADDR, 0, &regValue);
-		regValue |= 1<<15; //PHY Software Reset
-		mii_mgr_write(MAC_TO_GIGAPHY_MODE_ADDR, 0, regValue);
-	}
-// RT3052 + EmbeddedSW
+    enable_auto_negotiate();
+    if (isMarvellGigaPHY()) {
+#if defined (RT3883_FPGA_BOARD) 
+        mii_mgr_read(MAC_TO_GIGAPHY_MODE_ADDR, 9, &regValue);
+        regValue &= ~(3<<8); //turn off 1000Base-T Advertisement
+        mii_mgr_write(MAC_TO_GIGAPHY_MODE_ADDR, 9, regValue);
+#endif
+        printf("\n Reset MARVELL phy\n");
+        mii_mgr_read(MAC_TO_GIGAPHY_MODE_ADDR, 20, &regValue);
+        regValue |= 1<<7; //Add delay to RX_CLK for RXD Outputs
+        mii_mgr_write(MAC_TO_GIGAPHY_MODE_ADDR, 20, regValue);
+
+        mii_mgr_read(MAC_TO_GIGAPHY_MODE_ADDR, 0, &regValue);
+        regValue |= 1<<15; //PHY Software Reset
+        mii_mgr_write(MAC_TO_GIGAPHY_MODE_ADDR, 0, regValue);
+    }
+    // RT3052 + EmbeddedSW
 #elif defined (RT3052_ASIC_BOARD) || defined (RT3052_FPGA_BOARD) 
-	rt305x_esw_init();
-  #ifdef P5_RGMII_TO_MAC_MODE
-	printf("\n Vitesse giga Mac support \n");
-	ResetSWusingGPIO10();
-	udelay(125000);
-	vtss_init();
-  #endif
-// RT2880 + GigaSW
+    rt305x_esw_init();
+#ifdef P5_RGMII_TO_MAC_MODE
+    /*
+       printf("\n Vitesse giga Mac support \n");
+       ResetSWusingGPIO10();
+       udelay(125000);
+       vtss_init();
+     */
+    #ifdef CONFIG_AR8316
+    #warning "CONFIG_AR8316: RT2882_REG(0xb01100C8) &= 0xe0ffffff; athrs16_init athrs16_LAN_WAN_Par"
+    //using AR8316 GigaSW
+    printf("\n AR8316 Giga Switch support \n");
+    RT2882_REG(0xb01100C8) &= 0xe0ffffff; //set P5 external phy address to 0
+    athrs16_init();
+    athrs16_LAN_WAN_Par();        
+    #endif
+#endif
+    // RT2880 + GigaSW
 #elif defined (MAC_TO_VITESSE_MODE)
-	printf("\n Vitesse giga Mac support \n");
-	OUTL(dev, cpu_to_le32((u32)(0x1F01DC01)), RT2880_MDIO_CFG);
-	ResetSWusingGPIO10();
-	udelay(125000);
-	vtss_init();
+    printf("\n Vitesse giga Mac support \n");
+    OUTL(dev, cpu_to_le32((u32)(0x1F01DC01)), RT2880_MDIO_CFG);
+    ResetSWusingGPIO10();
+    udelay(125000);
+    vtss_init();
 
-// RT2880 + 100PHY
+    // RT2880 + 100PHY
 #elif MAC_TO_100PHY_MODE
-	// due to the flaws of RT2880 GMAC implementation (or IC+ SW ?) we use the
-	// fixed capability instead of auto-polling.
-	OUTL(dev, cpu_to_le32((u32)(0x1F01BC01)), RT2880_MDIO_CFG);
-
-	//force cpu port is 100F
-	mii_mgr_write(29, 22, 0x8420);
-	printf("\n Mac to 100Phy mode \n");
+    // due to the flaws of RT2880 GMAC implementation (or IC+ SW ?) we use the
+    // fixed capability instead of auto-polling.
+    OUTL(dev, cpu_to_le32((u32)(0x1F01BC01)), RT2880_MDIO_CFG);
+
+    //force cpu port is 100F
+    mii_mgr_write(29, 22, 0x8420);
+    printf("\n Mac to 100Phy mode \n");
 #endif // MAC_TO_GIGAPHY_MODE //
 
 #ifndef RT3052_PHY_TEST
-	LANWANPartition();
+    LANWANPartition();
 #endif
 
 
 #ifdef RT3883_USE_GE2
-	wTmp = (u16)dev->enetaddr[0];
-	regValue = (wTmp << 8) | dev->enetaddr[1];
-	OUTL(dev, regValue, RT2880_GDMA2_MAC_ADRH);
-
-	wTmp = (u16)dev->enetaddr[2];
-	regValue = (wTmp << 8) | dev->enetaddr[3];
-	regValue = regValue << 16;
-	wTmp = (u16)dev->enetaddr[4];
-	regValue |= (wTmp<<8) | dev->enetaddr[5];
-	OUTL(dev, regValue, RT2880_GDMA2_MAC_ADRL);
+    wTmp = (u16)dev->enetaddr[0];
+    regValue = (wTmp << 8) | dev->enetaddr[1];
+    OUTL(dev, regValue, RT2880_GDMA2_MAC_ADRH);
+
+    wTmp = (u16)dev->enetaddr[2];
+    regValue = (wTmp << 8) | dev->enetaddr[3];
+    regValue = regValue << 16;
+    wTmp = (u16)dev->enetaddr[4];
+    regValue |= (wTmp<<8) | dev->enetaddr[5];
+    OUTL(dev, regValue, RT2880_GDMA2_MAC_ADRL);
 
-	regValue = INL(dev, RT2880_GDMA2_FWD_CFG);
+    regValue = INL(dev, RT2880_GDMA2_FWD_CFG);
 
     if(is_internal_loopback_test)
     {
-    	regValue = regValue & RT2880_GDM_UFRC_P_CPU;
-		//Broad-cast MAC address frames forward to CPU
-		regValue = regValue & RT2880_GDM_BFRC_P_CPU;
-		//Multi-cast MAC address frames forward to CPU
-		regValue = regValue & RT2880_GDM_MFRC_P_CPU;
-    	//Other MAC address frames forward to CPU
-    	regValue = regValue & RT2880_GDM_OFRC_P_CPU;
+        regValue = regValue & RT2880_GDM_UFRC_P_CPU;
+        //Broad-cast MAC address frames forward to CPU
+        regValue = regValue & RT2880_GDM_BFRC_P_CPU;
+        //Multi-cast MAC address frames forward to CPU
+        regValue = regValue & RT2880_GDM_MFRC_P_CPU;
+        //Other MAC address frames forward to CPU
+        regValue = regValue & RT2880_GDM_OFRC_P_CPU;
 
 
-		//All Drop
+        //All Drop
 
-		regValue = regValue | RT2880_GDM_UFRC_P_DROP;
-		
-		regValue = regValue | RT2880_GDM_BFRC_P_DROP;
-		
-		regValue = regValue | RT2880_GDM_MFRC_P_DROP;
-    	
-    	regValue = regValue | RT2880_GDM_OFRC_P_DROP;
+        regValue = regValue | RT2880_GDM_UFRC_P_DROP;
 
-		printf("\n At interloopback mode, so all drop !\n");
+        regValue = regValue | RT2880_GDM_BFRC_P_DROP;
+
+        regValue = regValue | RT2880_GDM_MFRC_P_DROP;
+
+        regValue = regValue | RT2880_GDM_OFRC_P_DROP;
+
+        printf("\n At interloopback mode, so all drop !\n");
+    }
+    else
+    {
+        regValue = regValue & RT2880_GDM_UFRC_P_CPU;
+        //Broad-cast MAC address frames forward to CPU
+        regValue = regValue & RT2880_GDM_BFRC_P_CPU;
+        //Multi-cast MAC address frames forward to CPU
+        regValue = regValue & RT2880_GDM_MFRC_P_CPU;
+        //Other MAC address frames forward to CPU
+        regValue = regValue & RT2880_GDM_OFRC_P_CPU;
     }
-	else
-	{
-	regValue = regValue & RT2880_GDM_UFRC_P_CPU;
-	//Broad-cast MAC address frames forward to CPU
-	regValue = regValue & RT2880_GDM_BFRC_P_CPU;
-	//Multi-cast MAC address frames forward to CPU
-	regValue = regValue & RT2880_GDM_MFRC_P_CPU;
-	//Other MAC address frames forward to CPU
-	regValue = regValue & RT2880_GDM_OFRC_P_CPU;
-	}
 
-	OUTL(dev, cpu_to_le32((u32) regValue), RT2880_GDMA2_FWD_CFG);
-	udelay(500);
-	regValue = INL(dev, RT2880_GDMA2_FWD_CFG);
+    OUTL(dev, cpu_to_le32((u32) regValue), RT2880_GDMA2_FWD_CFG);
+    udelay(500);
+    regValue = INL(dev, RT2880_GDMA2_FWD_CFG);
 #else // non RT3883_USE_GE2 //
-	/* Set MAC address. */
-	wTmp = (u16)dev->enetaddr[0];
-	regValue = (wTmp << 8) | dev->enetaddr[1];
-	// printf("\n dev->iobase=%08X,RT2880_GDMA1_MAC_ADRH=%08X \nMAC_ADRH = %08X",dev->iobase,RT2880_GDMA1_MAC_ADRH,regValue);
-	OUTL(dev, regValue, RT2880_GDMA1_MAC_ADRH);
-
-	wTmp = (u16)dev->enetaddr[2];
-	regValue = (wTmp << 8) | dev->enetaddr[3];
-	regValue = regValue << 16;
-	wTmp = (u16)dev->enetaddr[4];
-	regValue |= (wTmp<<8) | dev->enetaddr[5];
-	//printf("\n dev->iobase=%08X,RT2880_GDMA1_MAC_ADRL=%08X \n MAC_ADRL = %08X",dev->iobase,RT2880_GDMA1_MAC_ADRL,regValue);
-	OUTL(dev, regValue, RT2880_GDMA1_MAC_ADRL);
-	//printf("\n rt2880_eth_init,set MAC reg to [%02X:%02X:%02X:%02X:%02X:%02X]\n",
-	//	dev->enetaddr[0],dev->enetaddr[1],dev->enetaddr[2],
-	//	dev->enetaddr[3],dev->enetaddr[4],dev->enetaddr[5]);
-
-	regValue = INL(dev, RT2880_GDMA1_FWD_CFG);
-	//printf("\n old,RT2880_GDMA1_FWD_CFG = %08X \n",regValue);
-
-	//Uni-cast frames forward to CPU
-	regValue = regValue & RT2880_GDM_UFRC_P_CPU;
-	//Broad-cast MAC address frames forward to CPU
-	regValue = regValue & RT2880_GDM_BFRC_P_CPU;
-	//Multi-cast MAC address frames forward to CPU
-	regValue = regValue & RT2880_GDM_MFRC_P_CPU;
-	//Other MAC address frames forward to CPU
-	regValue = regValue & RT2880_GDM_OFRC_P_CPU;
-
-	OUTL(dev, cpu_to_le32((u32) regValue), RT2880_GDMA1_FWD_CFG);
-	udelay(500);
-	regValue = INL(dev, RT2880_GDMA1_FWD_CFG);
-	//printf("\n new,RT2880_GDMA1_FWD_CFG = %08X \n",regValue);
+    /* Set MAC address. */
+    wTmp = (u16)dev->enetaddr[0];
+    regValue = (wTmp << 8) | dev->enetaddr[1];
+    // printf("\n dev->iobase=%08X,RT2880_GDMA1_MAC_ADRH=%08X \nMAC_ADRH = %08X",dev->iobase,RT2880_GDMA1_MAC_ADRH,regValue);
+    OUTL(dev, regValue, RT2880_GDMA1_MAC_ADRH);
+
+    wTmp = (u16)dev->enetaddr[2];
+    regValue = (wTmp << 8) | dev->enetaddr[3];
+    regValue = regValue << 16;
+    wTmp = (u16)dev->enetaddr[4];
+    regValue |= (wTmp<<8) | dev->enetaddr[5];
+    //printf("\n dev->iobase=%08X,RT2880_GDMA1_MAC_ADRL=%08X \n MAC_ADRL = %08X",dev->iobase,RT2880_GDMA1_MAC_ADRL,regValue);
+    OUTL(dev, regValue, RT2880_GDMA1_MAC_ADRL);
+    //printf("\n rt2880_eth_init,set MAC reg to [%02X:%02X:%02X:%02X:%02X:%02X]\n",
+    //	dev->enetaddr[0],dev->enetaddr[1],dev->enetaddr[2],
+    //	dev->enetaddr[3],dev->enetaddr[4],dev->enetaddr[5]);
+
+    regValue = INL(dev, RT2880_GDMA1_FWD_CFG);
+    //printf("\n old,RT2880_GDMA1_FWD_CFG = %08X \n",regValue);
+
+    //Uni-cast frames forward to CPU
+    regValue = regValue & RT2880_GDM_UFRC_P_CPU;
+    //Broad-cast MAC address frames forward to CPU
+    regValue = regValue & RT2880_GDM_BFRC_P_CPU;
+    //Multi-cast MAC address frames forward to CPU
+    regValue = regValue & RT2880_GDM_MFRC_P_CPU;
+    //Other MAC address frames forward to CPU
+    regValue = regValue & RT2880_GDM_OFRC_P_CPU;
+
+    OUTL(dev, cpu_to_le32((u32) regValue), RT2880_GDMA1_FWD_CFG);
+    udelay(500);
+    regValue = INL(dev, RT2880_GDMA1_FWD_CFG);
+    //printf("\n new,RT2880_GDMA1_FWD_CFG = %08X \n",regValue);
 #endif // RT3883_USE_GE2 //
 
-	regValue = 0x80504000;
-	OUTL(dev, cpu_to_le32((u32) regValue), RT2880_PSE_FQFC_CFG);
+    regValue = 0x80504000;
+    OUTL(dev, cpu_to_le32((u32) regValue), RT2880_PSE_FQFC_CFG);
 
 #ifdef RALINK_GDMA_DUP_TX_RING_TEST_FUN
-	tx_ring1 = KSEG1ADDR((ulong)&tx_ring1_cache[0]);
+    tx_ring1 = KSEG1ADDR((ulong)&tx_ring1_cache[0]);
 #endif
 
 #ifdef RALINK_GDMA_SCATTER_TEST_FUN
-	u32	kk;
-	if(header_payload_scatter_en == ENABLE)
-	{
-		temp = &PKT_HEADER_Buf[0] + (PKTALIGN - 1);
-		temp -= (ulong)temp % PKTALIGN;
+    u32	kk;
+    if(header_payload_scatter_en == ENABLE)
+    {
+        temp = &PKT_HEADER_Buf[0] + (PKTALIGN - 1);
+        temp -= (ulong)temp % PKTALIGN;
 
-		for (i = 0; i < PKTBUFSRX; i++) {
-			pkthdrbuf[i] = temp + (i*PKTSIZE_ALIGN) + sdp0_alig_16n_x;
+        for (i = 0; i < PKTBUFSRX; i++) {
+            pkthdrbuf[i] = temp + (i*PKTSIZE_ALIGN) + sdp0_alig_16n_x;
 
-			kk = (u32)pkthdrbuf[i];
-			printf("\n pkthdrbuf[%d]=0x%08X,16N alignment= %d \n",i,kk, (kk % FLANK_TEST_SPX_ALIGNMENT));
-		}
-	}
+            kk = (u32)pkthdrbuf[i];
+            printf("\n pkthdrbuf[%d]=0x%08X,16N alignment= %d \n",i,kk, (kk % FLANK_TEST_SPX_ALIGNMENT));
+        }
+    }
 #endif // RALINK_GDMA_SCATTER_TEST_FUN //
 
 
-	for (i = 0; i < NUM_RX_DESC; i++) {
-		temp = memset((void *)&rx_ring[i],0,16);
-		rx_ring[i].rxd_info2.DDONE_bit = 0;
+    for (i = 0; i < NUM_RX_DESC; i++) {
+        temp = memset((void *)&rx_ring[i],0,16);
+        rx_ring[i].rxd_info2.DDONE_bit = 0;
 
 #ifdef RALINK_GDMA_SCATTER_TEST_FUN
-		if(header_payload_scatter_en == ENABLE)
-		{
-			NetRxPackets[i]+= sdp1_alig_16n_x;
-			rx_ring[i].rxd_info1.PDP0 = cpu_to_le32(phys_to_bus((u32) pkthdrbuf[i]));
-			rx_ring[i].rxd_info3.PDP1 = cpu_to_le32(phys_to_bus((u32) (NetRxPackets[i])));
-			rx_ring[i].rxd_info2.LS0= 0;
-			rx_ring[i].rxd_info2.LS1= 1;
-			printf("\n rx_ring[%d].rxd_info3.PDP1 = 0x%08X",i,rx_ring[i].rxd_info3.PDP1);
-		}
-		else
+        if(header_payload_scatter_en == ENABLE)
+        {
+            NetRxPackets[i]+= sdp1_alig_16n_x;
+            rx_ring[i].rxd_info1.PDP0 = cpu_to_le32(phys_to_bus((u32) pkthdrbuf[i]));
+            rx_ring[i].rxd_info3.PDP1 = cpu_to_le32(phys_to_bus((u32) (NetRxPackets[i])));
+            rx_ring[i].rxd_info2.LS0= 0;
+            rx_ring[i].rxd_info2.LS1= 1;
+            printf("\n rx_ring[%d].rxd_info3.PDP1 = 0x%08X",i,rx_ring[i].rxd_info3.PDP1);
+        }
+        else
 #endif // RALINK_GDMA_SCATTER_TEST_FUN //
-		{
-			BUFFER_ELEM *buf;
-			buf = rt2880_free_buf_entry_dequeue(&rt2880_free_buf_list);
-			NetRxPackets[i] = buf->pbuf;
-			rx_ring[i].rxd_info2.LS0= 1;
-			rx_ring[i].rxd_info1.PDP0 = cpu_to_le32(phys_to_bus((u32) NetRxPackets[i]));
-		}
-	}
+        {
+            BUFFER_ELEM *buf;
+            buf = rt2880_free_buf_entry_dequeue(&rt2880_free_buf_list);
+            NetRxPackets[i] = buf->pbuf;
+            rx_ring[i].rxd_info2.LS0= 1;
+            rx_ring[i].rxd_info1.PDP0 = cpu_to_le32(phys_to_bus((u32) NetRxPackets[i]));
+        }
+    }
 
-	for (i=0; i < NUM_TX_DESC; i++) {
-		temp = memset((void *)&tx_ring0[i],0,16);
+    for (i=0; i < NUM_TX_DESC; i++) {
+        temp = memset((void *)&tx_ring0[i],0,16);
 #ifdef RALINK_MUTI_TX_DESCRIPTOR_TEST_FUN
-		//tx_ring0[i].txd_info2.LS1_bit = 1;
+        //tx_ring0[i].txd_info2.LS1_bit = 1;
 #else
-		tx_ring0[i].txd_info2.LS0_bit = 1;
+        tx_ring0[i].txd_info2.LS0_bit = 1;
 #endif
-		tx_ring0[i].txd_info2.DDONE_bit = 1;
-		/* PN:
-		 *  0:CPU
-		 *  1:GE1
-		 *  2:GE2 (for RT2883)
-		 *  6:PPE
-		 *  7:Discard
-		 */
-		if (internal_loopback_test == RT2880_INTERNAL_LOOPBACK_ENABLE) {
-			tx_ring0[i].txd_info4.PN = 0;
-			printf("\n Ring0,Set TX DMA loop back to CPU !! \n");
-		}
-		else {
+        tx_ring0[i].txd_info2.DDONE_bit = 1;
+        /* PN:
+         *  0:CPU
+         *  1:GE1
+         *  2:GE2 (for RT2883)
+         *  6:PPE
+         *  7:Discard
+         */
+        if (internal_loopback_test == RT2880_INTERNAL_LOOPBACK_ENABLE) {
+            tx_ring0[i].txd_info4.PN = 0;
+            printf("\n Ring0,Set TX DMA loop back to CPU !! \n");
+        }
+        else {
 #ifdef RT3883_USE_GE2
-			tx_ring0[i].txd_info4.PN = 2;
+            tx_ring0[i].txd_info4.PN = 2;
 #else
-			tx_ring0[i].txd_info4.PN = 1;
+            tx_ring0[i].txd_info4.PN = 1;
 #endif
-		}
+        }
 
-		tx_ring0[i].txd_info4.QN = 0;
-	}
+        tx_ring0[i].txd_info4.QN = 0;
+    }
 
 #ifdef RALINK_GDMA_DUP_TX_RING_TEST_FUN
-	for (i=0; i < NUM_TX_DESC; i++) {
-		temp = memset(&tx_ring1[i],0,16);
+    for (i=0; i < NUM_TX_DESC; i++) {
+        temp = memset(&tx_ring1[i],0,16);
 #ifdef RALINK_MUTI_TX_DESCRIPTOR_TEST_FUN
-		//tx_ring1[i].txd_info2.LS1_bit = 1;
+        //tx_ring1[i].txd_info2.LS1_bit = 1;
 #else
-		tx_ring1[i].txd_info2.LS0_bit = 1;
+        tx_ring1[i].txd_info2.LS0_bit = 1;
 #endif
-		tx_ring1[i].txd_info2.DDONE_bit = 1;
-		/* PN:
-		 *  0:CPU
-		 *  1:GE1
-		 *  2:GE2 (for RT2883)
-		 *  6:PPE
-		 *  7:Discard
-		 */
-		if (internal_loopback_test == RT2880_INTERNAL_LOOPBACK_ENABLE) {
-			tx_ring1[i].txd_info4.PN = 0;
-			printf("\n Ring1,Set TX DMA loop back to CPU ! \n");
-		}
-		else {
+        tx_ring1[i].txd_info2.DDONE_bit = 1;
+        /* PN:
+         *  0:CPU
+         *  1:GE1
+         *  2:GE2 (for RT2883)
+         *  6:PPE
+         *  7:Discard
+         */
+        if (internal_loopback_test == RT2880_INTERNAL_LOOPBACK_ENABLE) {
+            tx_ring1[i].txd_info4.PN = 0;
+            printf("\n Ring1,Set TX DMA loop back to CPU ! \n");
+        }
+        else {
 #ifdef RT3883_USE_GE2
-			tx_ring1[i].txd_info4.PN = 2;
+            tx_ring1[i].txd_info4.PN = 2;
 #else
-			tx_ring1[i].txd_info4.PN = 1;
+            tx_ring1[i].txd_info4.PN = 1;
 #endif
-		}
+        }
 
-		tx_ring1[i].txd_info4.QN = 0;
-	}
+        tx_ring1[i].txd_info4.QN = 0;
+    }
 #endif // RALINK_GDMA_DUP_TX_RING_TEST_FUN //
 
-	rxRingSize = NUM_RX_DESC;
-	txRingSize = NUM_TX_DESC;
+    rxRingSize = NUM_RX_DESC;
+    txRingSize = NUM_TX_DESC;
 
-	rx_dma_owner_idx0 = 0;
-	rx_wants_alloc_idx0 = (NUM_RX_DESC - 1);
-	tx_cpu_owner_idx0 = 0;
-	tx_cpu_owner_idx1 = 0;
+    rx_dma_owner_idx0 = 0;
+    rx_wants_alloc_idx0 = (NUM_RX_DESC - 1);
+    tx_cpu_owner_idx0 = 0;
+    tx_cpu_owner_idx1 = 0;
 
-	regValue=INL(rt2880_pdev, RT2880_PDMA_GLO_CFG);
-	udelay(100);
+    regValue=INL(rt2880_pdev, RT2880_PDMA_GLO_CFG);
+    udelay(100);
 
 #ifdef RALINK_GDMA_SCATTER_TEST_FUN
-	if(header_payload_scatter_en == ENABLE)
-	{
-		regValue &= 0x0000FFFF;
-		regValue |= (rt2880_hdrlen << 16);
-		OUTL(dev, regValue, RT2880_PDMA_GLO_CFG);
-		udelay(500);
-		regValue=INL(dev, RT2880_PDMA_GLO_CFG);
-		printf("\n  Default of Header Length = 20 \n");
-		printf("\n RT2880_PDMA_GLO_CFG=%08X \n",regValue);
-	}
-	else
+    if(header_payload_scatter_en == ENABLE)
+    {
+        regValue &= 0x0000FFFF;
+        regValue |= (rt2880_hdrlen << 16);
+        OUTL(dev, regValue, RT2880_PDMA_GLO_CFG);
+        udelay(500);
+        regValue=INL(dev, RT2880_PDMA_GLO_CFG);
+        printf("\n  Default of Header Length = 20 \n");
+        printf("\n RT2880_PDMA_GLO_CFG=%08X \n",regValue);
+    }
+    else
 #endif // RALINK_GDMA_SCATTER_TEST_FUN //
-	{
-		regValue &= 0x0000FFFF;
+    {
+        regValue &= 0x0000FFFF;
 
-		OUTL(rt2880_pdev, regValue, RT2880_PDMA_GLO_CFG);
-		udelay(500);
-		regValue=INL(rt2880_pdev, RT2880_PDMA_GLO_CFG);
+        OUTL(rt2880_pdev, regValue, RT2880_PDMA_GLO_CFG);
+        udelay(500);
+        regValue=INL(rt2880_pdev, RT2880_PDMA_GLO_CFG);
 #ifndef RT3052_PHY_TEST
-		printf("\n Header Payload scatter function is Disable !! \n");
+        printf("\n Header Payload scatter function is Disable !! \n");
 #endif
-	}
+    }
 
 #ifdef RALINK_GDMA_DUP_TX_RING_TEST_FUN
-	OUTL(dev, phys_to_bus((u32) &tx_ring1[0]), RT2880_TX_BASE_PTR1);
-	OUTL(dev, cpu_to_le32((u32) NUM_TX_DESC), RT2880_TX_MAX_CNT1);
-	OUTL(dev, cpu_to_le32((u32) tx_cpu_owner_idx1), RT2880_TX_CTX_IDX1);
+    OUTL(dev, phys_to_bus((u32) &tx_ring1[0]), RT2880_TX_BASE_PTR1);
+    OUTL(dev, cpu_to_le32((u32) NUM_TX_DESC), RT2880_TX_MAX_CNT1);
+    OUTL(dev, cpu_to_le32((u32) tx_cpu_owner_idx1), RT2880_TX_CTX_IDX1);
 #endif // RALINK_GDMA_DUP_TX_RING_TEST_FUN //
 
-	/* Tell the adapter where the TX/RX rings are located. */
-	OUTL(dev, phys_to_bus((u32) &rx_ring[0]), RT2880_RX_BASE_PTR0);
+    /* Tell the adapter where the TX/RX rings are located. */
+    OUTL(dev, phys_to_bus((u32) &rx_ring[0]), RT2880_RX_BASE_PTR0);
 
-	//printf("\n rx_ring=%08X ,RT2880_RX_BASE_PTR0 = %08X \n",&rx_ring[0],INL(dev,RT2880_RX_BASE_PTR0));
-	OUTL(dev, phys_to_bus((u32) &tx_ring0[0]), RT2880_TX_BASE_PTR0);
+    //printf("\n rx_ring=%08X ,RT2880_RX_BASE_PTR0 = %08X \n",&rx_ring[0],INL(dev,RT2880_RX_BASE_PTR0));
+    OUTL(dev, phys_to_bus((u32) &tx_ring0[0]), RT2880_TX_BASE_PTR0);
 
-	//printf("\n tx_ring0=%08X, RT2880_TX_BASE_PTR0 = %08X \n",&tx_ring0[0],INL(dev,RT2880_TX_BASE_PTR0));
+    //printf("\n tx_ring0=%08X, RT2880_TX_BASE_PTR0 = %08X \n",&tx_ring0[0],INL(dev,RT2880_TX_BASE_PTR0));
 
-	OUTL(dev, cpu_to_le32((u32) NUM_RX_DESC), RT2880_RX_MAX_CNT0);
-	OUTL(dev, cpu_to_le32((u32) NUM_TX_DESC), RT2880_TX_MAX_CNT0);
+    OUTL(dev, cpu_to_le32((u32) NUM_RX_DESC), RT2880_RX_MAX_CNT0);
+    OUTL(dev, cpu_to_le32((u32) NUM_TX_DESC), RT2880_TX_MAX_CNT0);
 
-	OUTL(dev, cpu_to_le32((u32) tx_cpu_owner_idx0), RT2880_TX_CTX_IDX0);
-	OUTL(dev, cpu_to_le32((u32) (NUM_RX_DESC - 1)), RT2880_RX_CALC_IDX0);
-	//OUTL(dev, cpu_to_le32((u32) 0), RT2880_RX_DRX_IDX0);
-	
-	udelay(500);
-	START_RT2880_ETH(dev);
-	
-	return 1;
+    OUTL(dev, cpu_to_le32((u32) tx_cpu_owner_idx0), RT2880_TX_CTX_IDX0);
+    OUTL(dev, cpu_to_le32((u32) (NUM_RX_DESC - 1)), RT2880_RX_CALC_IDX0);
+    //OUTL(dev, cpu_to_le32((u32) 0), RT2880_RX_DRX_IDX0);
+
+    udelay(500);
+    START_RT2880_ETH(dev);
+
+    return 1;
 }
 
 
--- Uboot-1.1.3/drivers/mii_mgr.c	2009-12-17 16:48:56.000000000 +0800
+++ Uboot-1.1.3/drivers/mii_mgr.c	2010-04-23 17:32:22.373254861 +0800
@@ -1,3 +1,4 @@
+#include <../autoconf.h>
 #include <common.h>
 #include <command.h>
 #include <rt_mmap.h>
@@ -7,10 +8,13 @@
 #define outw(address, value)    *((volatile uint32_t *)(address)) = cpu_to_le32(value)
 #define inw(address)            le32_to_cpu(*(volatile u32 *)(address))
 
+
 #if defined (RT3052_FPGA_BOARD) || defined (RT3052_ASIC_BOARD)
+
+
 #define PHY_CONTROL_0 		0xC0   
 #define PHY_CONTROL_1 		0xC4   
-#define MDIO_PHY_CONTROL_0  (RALINK_ETH_SW_BASE + PHY_CONTROL_0)
+#define MDIO_PHY_CONTROL_0  	(RALINK_ETH_SW_BASE + PHY_CONTROL_0)
 #define MDIO_PHY_CONTROL_1 	(RALINK_ETH_SW_BASE + PHY_CONTROL_1)
 
 #define GPIO_MDIO_BIT		(1<<7)
@@ -23,12 +27,14 @@
 #define MDIO_PHY_CONTROL_0	(RALINK_FRAME_ENGINE_BASE + PHY_CONTROL_0)
 #define MDIO_PHY_CONTROL_1	(RALINK_FRAME_ENGINE_BASE + PHY_CONTROL_1)
 #define enable_mdio(x)
+
 #endif
 
 #if defined (RT3052_FPGA_BOARD) || defined (RT3052_ASIC_BOARD)
 void enable_mdio(int enable)
 {
 #if !defined (P5_MAC_TO_PHY_MODE)
+    #warning "CONFIG with 3052 and MAC to PHY"
 	u32 data = inw(GPIO_PRUPOSE);
 	if(enable)
 		data &= ~GPIO_MDIO_BIT;
@@ -44,10 +50,10 @@
 {
 	u32 volatile  			status	= 0;
 	u32 volatile  			data 	= 0;
-	u32			  			rc		= 0;
+	u32			  	rc	= 0;
 	unsigned long volatile  t_start = get_timer(0);
 
-	/* We enable mdio gpio purpose register, and disable it when exit.	 */
+	//We enable mdio gpio purpose register, and disable it when exit.
 	enable_mdio(1);
 
 	// make sure previous read operation is complete
@@ -266,6 +272,343 @@
 	}
 	return 0;
 }
+/* EZP: Supported for AR8316 giga switch */
+#ifdef CONFIG_AR8316
+#warning "CONFIG_AR8316: athrs16_reg_read, athrs16_reg_write, athrs16_init and athrs16_LAN_WAN_Par"
+//#define outw(address, value)    *((volatile uint32_t *)(address)) = cpu_to_le32(value)
+//#define inw(address)            le32_to_cpu(*(volatile u32 *)(address))
+static uint32_t
+athrs16_reg_read(uint32_t reg_addr)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr, tmp_val, reg_val;
+    uint32_t phy_val;
+    uint32_t phy_reg;
+    //uint32_t mo_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = ((reg_word_addr >> 8) & 0x3ff);  /* A18-A9 of reg address */
+    //change P5 external PHY address before operation
+    //mo_reg = inw(0xb01100c8);
+    //mo_reg &= 0xe0ffffff;
+    //mo_reg |= (phy_addr << 24); 
+    //outw(0xb01100c8, mo_reg);
+    mii_mgr_write(phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* A8-A6 of reg address */
+    phy_reg = (reg_word_addr & 0x1f);   /* A5-A1 of reg address */
+    //change P5 external PHY address before operation
+    //mo_reg = inw(0xb01100c8);
+    //mo_reg &= 0xe0ffffff;
+    //mo_reg |= (phy_addr << 24); 
+    //outw(0xb01100c8, mo_reg);
+    mii_mgr_read(phy_addr, phy_reg, &reg_val);
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* A8-A6 of reg address */
+    phy_reg = (reg_word_addr & 0x1f);   /* A5-A1 of reg address */
+    //change P5 external PHY address before operation
+    //mo_reg = inw(0xb01100c8);
+    //mo_reg &= 0xe0ffffff;
+    //mo_reg |= (phy_addr << 24); 
+    //outw(0xb01100c8, mo_reg);
+    mii_mgr_read(phy_addr, phy_reg, &tmp_val);
+    reg_val |= (tmp_val << 16);
+
+    return reg_val;   
+}
+
+static void
+athrs16_reg_write(uint32_t reg_addr, uint32_t reg_val)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr;
+    uint32_t phy_val;
+    uint32_t phy_reg;
+    //uint32_t mo_reg;
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = ((reg_word_addr >> 8) & 0x3ff);  /* A18-A9 of reg address */
+    //change P5 external PHY address before operation
+    //mo_reg = inw(0xb01100c8);
+    //mo_reg &= 0xe0ffffff;
+    //mo_reg |= (phy_addr << 24); 
+    //outw(0xb01100c8, mo_reg);
+    mii_mgr_write(phy_addr, phy_reg, phy_val);
+
+    /* For some registers such as ARL and VLAN, since they include BUSY bit */
+    /* in lower address, we should write the higher 16-bit register then the */
+    /* lower one */
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* A8-A6 of reg address */
+    phy_reg = (reg_word_addr & 0x1f);   /* A5-A1 of reg address */
+    phy_val = ((reg_val >> 16) & 0xffff);
+    //change P5 external PHY address before operation
+    //mo_reg = inw(0xb01100c8);
+    //mo_reg &= 0xe0ffffff;
+    //mo_reg |= (phy_addr << 24); 
+    //outw(0xb01100c8, mo_reg);
+    mii_mgr_write(phy_addr, phy_reg, phy_val);
+
+    /* write register in lower address */
+    reg_word_addr--;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* A8-A6 of reg address */
+    phy_reg = (reg_word_addr & 0x1f);   /* A5-A1 of reg address */
+    phy_val = (reg_val & 0xffff);
+    //change P5 external PHY address before operation
+    //mo_reg = inw(0xb01100c8);
+    //mo_reg &= 0xe0ffffff;
+    //mo_reg |= (phy_addr << 24); 
+    //outw(0xb01100c8, mo_reg);
+    mii_mgr_write(phy_addr, phy_reg, phy_val); 
+}
+
+#define BITS(_s, _n) 	(((1UL << (_n)) - 1) << _s)
+#define BIT(_s) (1UL << _s)
+
+#define AR8316_REG_VTU                  0x0040
+#define   AR8316_VTU_OP                 BITS(0, 3)
+#define   AR8316_VTU_OP_NOOP            0x0
+#define   AR8316_VTU_OP_FLUSH           0x1
+#define   AR8316_VTU_OP_LOAD            0x2
+#define   AR8316_VTU_OP_PURGE           0x3
+#define   AR8316_VTU_OP_REMOVE_PORT     0x4
+#define   AR8316_VTU_ACTIVE             BIT(3)
+#define   AR8316_VTU_PORT               BITS(8, 4)
+#define   AR8316_VTU_PORT_S             8
+#define   AR8316_VTU_VID                BITS(16, 12)
+#define   AR8316_VTU_VID_S              16
+#define   AR8316_VTU_PRIO               BITS(28, 3)
+#define   AR8316_VTU_PRIO_S             28
+#define   AR8316_VTU_PRIO_EN            BIT(31)
+
+#define AR8316_REG_VTU_DATA             0x0044
+#define   AR8316_VTUDATA_MEMBER         BITS(0, 6)
+#define   AR8316_VTUDATA_VALID          BIT(11)
+	
+static void
+ar8316_vtu_op( u32 op, u32 val)
+{
+    //check Vlan Table is not on busy
+    if ((athrs16_reg_read(0x0040)& AR8316_VTU_ACTIVE)== AR8316_VTU_ACTIVE)
+        return;
+    if ((op & AR8316_VTU_OP) == AR8316_VTU_OP_LOAD) {
+        val &= AR8316_VTUDATA_MEMBER;
+        val |= AR8316_VTUDATA_VALID;
+        athrs16_reg_write(AR8316_REG_VTU_DATA, val);
+    }
+    //set VT_BUSY=1 to make VT start operation
+    op |= AR8316_VTU_ACTIVE;
+    athrs16_reg_write(AR8316_REG_VTU, op);
+}
+
+void athrs16_init()
+{
+    static int athr16_init_flag=0;
+    uint32_t po_reg_val; 
+    /* if using header for register configuration, we have to     */
+    /* configure s16 register after frame transmission is enabled */
+    if (athr16_init_flag)
+        return;
+
+    /*Power on strip mode setup*/
+    /*Configure the MAC0 RGMII PHY mode, and enable the input clock delay*/
+    /*AR8316 only support RGMII MAC0 PHY mode. MACO in MAC mode is only supported when us GMII*/
+    /*RT3052 only have RGMII interface, hence MAC0 of AR8316 is set to PHY mode in this case*/
+    athrs16_reg_write(0x8, 0x012e1be2);
+    /*The MAC0 speed/duplex is enabled by CPU. The link status of MAC1~MAC5 */
+    /*are controlled by PHY0~PHY4*/
+    athrs16_reg_write(0x100, 0x7e);
+    athrs16_reg_write(0x200, 0x0200);
+    athrs16_reg_write(0x300, 0x0200);
+    athrs16_reg_write(0x400, 0x0200);
+    athrs16_reg_write(0x500, 0x0200);
+    athrs16_reg_write(0x600, 0x0200);
+    /*unitcast and multicast flood destination port*/
+    //athrs16_reg_write(0x2c, 0x003f003f);
+
+    /*allow single vlan tag to be transmitted and received for all port*/
+    /*Enable learning and forwarding*/
+    athrs16_reg_write(0x104, 0x6004);
+    athrs16_reg_write(0x204, 0x6004);
+    athrs16_reg_write(0x304, 0x6004);
+    athrs16_reg_write(0x404, 0x6004);
+    athrs16_reg_write(0x504, 0x6004);    
+    athrs16_reg_write(0x604, 0x6004);
+
+    //get Power-On Strapping Reg Value to verify we indeed write the correct value.
+    po_reg_val = athrs16_reg_read(0x8);
+    //printk("\n AR8316's Power-On Strapping Reg Value is 0x%08X \n", po_reg_val);
+    //printk("\n AR8316's MAC0 started as PHY mode in RGMII.\n");
+    printf("AR8316 Support!!\n");
+
+    athr16_init_flag = 1;
+}
+/* Enable VLAN for Port Partitions
+ use port-based VLAN only
+ in the AR8316, there are 3 relative register to be set(every port has its own reg., eg. per port settings)
+ 1. PVID for ingress port. When untag frame comes in, the VID will be PVID
+ 2. Tag/unTag for egress port. When frame is going out the port, VID tag can be add, remove or unmofified. 
+ 3. Port member for each port. AR8316's port-based VLAN is VLAN table independent, and this port member setting restrict the 	 frame forwarding.
+*/
+void athrs16_LAN_WAN_Par(void)
+{
+    //port arrangement is LLLLW, P1~P5    
+    //port member for each port
+    //P0:111110 = 0x3E
+    //P1:011101 = 0x1D
+    //P2:011011 = 0x1B
+    //P3:010111 = 0x17
+    //P4:001111 = 0x0F
+    //P5:000001 = 0x01
+
+    //PVID setting
+    //P0:1
+    //P1:1
+    //P2:1
+    //P3:1
+    //P4:1
+    //P5:2
+
+    //Egress Port Tagging
+    //P0:tag/unmodified
+    //P1:untag
+    //P2:untag
+    //P3:untag
+    //P4:untag
+    //P5:untag
+
+    //reg value for Port-based VLAN register(0x108,0x208,0x308,0x408,0x508,0x608)
+    //0x108 = 0x003E0001
+    //0x208 = 0x001D0001
+    //0x308 = 0x001B0001
+    //0x408 = 0x00170001
+    //0x508 = 0x000F0001
+    //0x608 = 0x00010002
+
+    //reg value for Port Control register(0x104, 0x204, 0x304, 0x404, 0x504, 0x604)
+    //the initial value for this is 00, means unmodifying the tag. So, we don't need to set this.
+
+    athrs16_reg_write(0x108, 0x003e0001);
+    athrs16_reg_write(0x208, 0x001d0001);
+    athrs16_reg_write(0x308, 0x001b0001);
+    athrs16_reg_write(0x408, 0x00170001);
+    athrs16_reg_write(0x508, 0x000f0001);
+    athrs16_reg_write(0x608, 0x00010002);
+
+
+    //P0 tag,
+    athrs16_reg_write(0x104, 0x00006204);
+    //P1 untag
+    athrs16_reg_write(0x204, 0x00006104);
+    //P2 untag
+    athrs16_reg_write(0x304, 0x00006104);
+    //P3 untag
+    athrs16_reg_write(0x404, 0x00006104);
+    //P4 untag
+    athrs16_reg_write(0x504, 0x00006104);
+    //P5 untag
+    athrs16_reg_write(0x604, 0x00006104);
+    /*
+    // check VT is busy
+    u32 temp=0;
+    temp = athrs16_reg_read(0x0040);
+    temp = temp&0x00000004;
+    while (temp == 0x4){
+    athrs16_reg_write(0x0044, 0x0000080e);
+    athrs16_reg_write(0x0040, 0x0001000a);
+    }
+    temp = athrs16_reg_read(0x0040);
+    temp = temp&0x00000004;
+    while (temp == 0x4){
+    athrs16_reg_write(0x0044, 0x00000818);
+    athrs16_reg_write(0x0040, 0x0002000a);
+    }
+     */
+    /*
+    // This is a test !! We test the tag is outting from P3
+    u32 temp;
+
+    //P0: PVID=1, port_mem=(P0,P5), ingress=port_vlan, egress=untag
+    athrs16_reg_write(0x108, 0x00200001);
+    temp = athrs16_reg_read(0x108);
+    printf("\n Port Settin 0xn08 is %08x \n", temp);
+
+    //P1: PVID=2, port_mem=(P1, P2, P3), ingress=port_vlan, egress=untag	
+    athrs16_reg_write(0x208, 0x000c0002);
+    temp = athrs16_reg_read(0x208);
+    printf("\n Port Settin 0xn08 is %08x \n", temp);
+
+    //P2: PVID=2, port_mem=(P1, P2, P3), ingress=port_vlan, egress=untag
+    athrs16_reg_write(0x308, 0x000a0002);
+    temp = athrs16_reg_read(0x308);
+    printf("\n Port Settin 0xn08 is %08x \n", temp);
+
+    //P3: PVID=5, port_mem=(P1, P2, P3, P4), ingress=port_vlan, egress=tag
+    athrs16_reg_write(0x408, 0x00160005);
+    temp = athrs16_reg_read(0x408);
+    printf("\n Port Settin 0xn08 is %08x \n", temp);
+
+    //P4: PVID=3, port_mem=(P3, P4), ingress=port_vlan, egress=untag
+    athrs16_reg_write(0x508, 0x00080003);
+    temp = athrs16_reg_read(0x508);
+    printf("\n Port Settin 0xn08 is %08x \n", temp);
+
+    //P5: PVID=1, port_mem=(P0,P5), ingress=port_vlan, egress=untag
+    athrs16_reg_write(0x608, 0x00010001);
+    temp = athrs16_reg_read(0x608);
+    printf("\n Port Settin 0xn08 is %08x \n", temp);
+
+
+    //force P3 add tag on egress to see if there is a tag exit
+    //P0 untag
+    athrs16_reg_write(0x104, 0x00006104);
+    temp = athrs16_reg_read(0x104);
+    printf("\n Port Settin 0xn04 is %08x \n", temp);
+    //P1 untag
+    athrs16_reg_write(0x204, 0x00006104);
+    temp = athrs16_reg_read(0x204);
+    printf("\n Port Settin 0xn04 is %08x \n", temp);
+    //P2 untag
+    athrs16_reg_write(0x304, 0x00006104);
+    temp = athrs16_reg_read(0x304);
+    printf("\n Port Settin 0xn04 is %08x \n", temp);
+    //P3 tag
+    athrs16_reg_write(0x404, 0x00006304);
+    temp = athrs16_reg_read(0x404);
+    printf("\n Port Settin 0xn04 is %08x \n", temp);
+    //P4 untag
+    athrs16_reg_write(0x504, 0x00006104);
+    temp = athrs16_reg_read(0x504);
+    printf("\n Port Settin 0xn04 is %08x \n", temp);
+    //P5 untag
+    athrs16_reg_write(0x604, 0x00006104);
+    temp = athrs16_reg_read(0x604);
+    printf("\n Port Settin 0xn04 is %08x \n", temp);
+
+    printf("\n AR8316 VLAN Support Now.\n");
+
+    */
+}
+
+#endif /* EZP: Support for AR8316 */
 
 U_BOOT_CMD(
  	mdio,	4,	1,	rt2880_mdio_access,
